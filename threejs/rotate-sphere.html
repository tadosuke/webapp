<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sphere</title>
</head>
<body style="margin: 0; overflow: hidden;">
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';

    const rotationQuaternion = new THREE.Quaternion();
    let isDragging = false;
    let prevPointer = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    const friction = 0.95;
    const minVelocityThreshold = 0.00001;

    // シーンを作成して DOM に追加
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 2;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const sphere = createsphere();
    setupLights();
    addEventListeners();
    updateAnimation();

    // イベントリスナーの設定
    function addEventListeners() {
      renderer.domElement.addEventListener('pointerdown', handlePointerDown);
      renderer.domElement.addEventListener('pointermove', handlePointerMove);
      renderer.domElement.addEventListener('pointerup', handlePointerUp);
      renderer.domElement.addEventListener('pointercancel', handlePointerUp);
      renderer.domElement.addEventListener('pointerleave', handlePointerUp);

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // ポインタ操作開始時の処理
    function handlePointerDown(e) {
      isDragging = true;
      prevPointer = { x: e.clientX, y: e.clientY };
      velocity = { x: 0, y: 0 };
      e.target.setPointerCapture(e.pointerId);
    }

    // ポインタ移動中の処理
    function handlePointerMove(e) {
      if (!isDragging) return;
      const deltaX = e.clientX - prevPointer.x;
      const deltaY = e.clientY - prevPointer.y;
      applyRotation(deltaX, deltaY);
      velocity = { x: deltaX * 0.5, y: deltaY * 0.5 };
      prevPointer = { x: e.clientX, y: e.clientY };
    }

    // ポインタ操作終了時の処理
    function handlePointerUp(e) {
      isDragging = false;
      e.target.releasePointerCapture(e.pointerId);
    }

    // 球を生成する
    function createsphere() {
      const sphereTexture = new THREE.TextureLoader().load('./texture.jpg');
      sphereTexture.wrapS = THREE.RepeatWrapping;
      sphereTexture.wrapT = THREE.RepeatWrapping;
      sphereTexture.repeat.set(1, 1);

      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(1, 32, 32),
        new THREE.MeshStandardMaterial({ map: sphereTexture })
      );
      scene.add(sphere);
      return sphere;
    }

    // 回転を適用する
    function applyRotation(deltaX, deltaY) {
      const xAxis = new THREE.Vector3(1, 0, 0);
      const yAxis = new THREE.Vector3(0, 1, 0);
      const qY = new THREE.Quaternion().setFromAxisAngle(yAxis, deltaX * 0.005);
      const qX = new THREE.Quaternion().setFromAxisAngle(xAxis, deltaY * 0.005);
      rotationQuaternion.multiplyQuaternions(qY, rotationQuaternion);
      rotationQuaternion.multiplyQuaternions(qX, rotationQuaternion);
      sphere.quaternion.copy(rotationQuaternion);
    }

    // ライトのセットアップ
    function setupLights() {
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
      directionalLight.position.set(5, 3, 5).normalize();
      scene.add(directionalLight);
    }

    // アニメーションの更新
    function updateAnimation() {
      requestAnimationFrame(updateAnimation);

      if (!isDragging) {
        applyRotation(velocity.x, velocity.y);
        velocity.x *= friction;
        velocity.y *= friction;

        if (Math.abs(velocity.x) < minVelocityThreshold) velocity.x = 0;
        if (Math.abs(velocity.y) < minVelocityThreshold) velocity.y = 0;
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
