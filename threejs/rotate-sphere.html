<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sphere</title>
</head>
<body style="margin: 0; overflow: hidden;">
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
    
    const rotationQuaternion = new THREE.Quaternion();
    let isDragging = false;
    let prevMouse = { x: 0, y: 0 };
    let velocity = { x: 0, y: 0 };
    const friction = 0.95; // 摩擦係数
    const minVelocityThreshold = 0.00001; // 最小回転速度

    // シーンを作成して DOM に追加
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 3;
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    const sphere = createsphere();
    setupLights();
    addEventListeners();
    updateAnimation();

    // イベントリスナーの設定
    function addEventListeners() {
      // マウスイベント
      renderer.domElement.addEventListener('mousedown', handleMouseDown);
      renderer.domElement.addEventListener('mousemove', handleMouseMove);
      renderer.domElement.addEventListener('mouseup', handleMouseUp);
      renderer.domElement.addEventListener('mouseleave', handleMouseLeave);

      // タッチイベント
      renderer.domElement.addEventListener('touchstart', handleTouchStart);
      renderer.domElement.addEventListener('touchmove', handleTouchMove);
      renderer.domElement.addEventListener('touchend', handleTouchEnd);

      // ウィンドウサイズ変更イベント
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // マウス操作開始時の処理
    function handleMouseDown(e) {
      isDragging = true;
      prevMouse = { x: e.clientX, y: e.clientY };
      velocity = { x: 0, y: 0 };
    }

    // マウス操作中の処理
    function handleMouseMove(e) {
      if (!isDragging) return;
      const deltaX = e.clientX - prevMouse.x;
      const deltaY = e.clientY - prevMouse.y;
      applyRotation(deltaX, deltaY);
      velocity = { x: deltaX * 0.5, y: deltaY * 0.5 };
      prevMouse = { x: e.clientX, y: e.clientY };
    }

    // マウスボタンを離した時の処理
    function handleMouseUp() {
      isDragging = false;
    }

    // マウスが画面外に出た場合の処理
    function handleMouseLeave() {
      isDragging = false;
    }

    // タッチ開始時の処理
    function handleTouchStart(e) {
      isDragging = true;
      const touch = e.touches[0];
      prevMouse = { x: touch.clientX, y: touch.clientY };
      velocity = { x: 0, y: 0 };
    }

    // タッチ移動中の処理
    function handleTouchMove(e) {
      if (!isDragging) return;
      const touch = e.touches[0];
      const deltaX = touch.clientX - prevMouse.x;
      const deltaY = touch.clientY - prevMouse.y;
      applyRotation(deltaX, deltaY);
      velocity = { x: deltaX * 0.5, y: deltaY * 0.5 };
      prevMouse = { x: touch.clientX, y: touch.clientY };
    }

    // タッチ終了時の処理
    function handleTouchEnd() {
      isDragging = false;
    }

    // 球を生成する
    function createsphere() {
      const sphereTexture = new THREE.TextureLoader().load('./texture.jpg');
      sphereTexture.wrapS = THREE.RepeatWrapping;
      sphereTexture.wrapT = THREE.RepeatWrapping;
      sphereTexture.repeat.set(1, 1);

      const sphere = new THREE.Mesh(
        new THREE.SphereGeometry(1, 32, 32),
        new THREE.MeshStandardMaterial({ map: sphereTexture })
      );
      scene.add(sphere);
      return sphere;
    }

    // 回転を適用する
    function applyRotation(deltaX, deltaY) {
      const xAxis = new THREE.Vector3(1, 0, 0);
      const yAxis = new THREE.Vector3(0, 1, 0);
      const qY = new THREE.Quaternion().setFromAxisAngle(yAxis, deltaX * 0.005);
      const qX = new THREE.Quaternion().setFromAxisAngle(xAxis, deltaY * 0.005);
      rotationQuaternion.multiplyQuaternions(qY, rotationQuaternion);
      rotationQuaternion.multiplyQuaternions(qX, rotationQuaternion);
      sphere.quaternion.copy(rotationQuaternion);
    }

    // ライトのセットアップ
    function setupLights() {
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
      directionalLight.position.set(5, 3, 5).normalize();
      scene.add(directionalLight);
    }

    // アニメーションの更新
    function updateAnimation() {
      requestAnimationFrame(updateAnimation);

      if (!isDragging) {
        applyRotation(velocity.x, velocity.y);
        velocity.x *= friction;
        velocity.y *= friction;

        if (Math.abs(velocity.x) < minVelocityThreshold) velocity.x = 0;
        if (Math.abs(velocity.y) < minVelocityThreshold) velocity.y = 0;
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
