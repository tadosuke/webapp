<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js 地球儀</title>
</head>
<body style="margin: 0; overflow: hidden;">
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
      
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 3;
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
      
        // 地球
        const earth = createEarth();
      
        // ライト
        setupLights();
      
        const rotationQuaternion = new THREE.Quaternion();
        const xAxis = new THREE.Vector3(1, 0, 0);
        const yAxis = new THREE.Vector3(0, 1, 0);
        let isDragging = false;
        let prevMouse = { x: 0, y: 0 };
        let velocity = { x: 0, y: 0 };
        const friction = 0.995;
        const minVelocityThreshold = 0.00001;
                  
        // マウス操作開始時の処理
        renderer.domElement.addEventListener('mousedown', (e) => {
          isDragging = true;
          prevMouse = { x: e.clientX, y: e.clientY };
          velocity = { x: 0, y: 0 }; // ドラッグ開始時に速度をリセット
        });
      
        // マウス操作中の処理
        renderer.domElement.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          const deltaX = e.clientX - prevMouse.x;
          const deltaY = e.clientY - prevMouse.y;
          applyRotation(deltaX, deltaY);
      
          // マウスの移動速度を慣性速度に記録
          velocity = { x: deltaX * 0.5, y: deltaY * 0.5 };
          prevMouse = { x: e.clientX, y: e.clientY };
        });
      
        // マウスボタンを離した時の処理
        renderer.domElement.addEventListener('mouseup', () => {
          isDragging = false;
          // マウスを離した時点での速度をそのまま使用
        });
      
        // マウスが画面外に出た場合の処理
        renderer.domElement.addEventListener('mouseleave', () => {
          isDragging = false;
        });
            
        // アニメーションのメイン処理
        const animate = () => {
          requestAnimationFrame(animate);
      
          if (!isDragging) {
            // アニメーション更新関数を呼び出す
            updateAnimation();
          }
      
          renderer.render(scene, camera);
        };
      
        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });
      
        animate();

        // 地球を生成する関数
        function createEarth() {
            const earthTexture = new THREE.TextureLoader().load('./earth_texture.jpg');
            const earth = new THREE.Mesh(
            new THREE.SphereGeometry(1, 32, 32),
            new THREE.MeshStandardMaterial({ map: earthTexture })
            );
            scene.add(earth);
            return earth;
        }

        // 回転を適用する関数
        function applyRotation(deltaX, deltaY) {
            const qY = new THREE.Quaternion().setFromAxisAngle(yAxis, deltaX * 0.005);
            const qX = new THREE.Quaternion().setFromAxisAngle(xAxis, deltaY * 0.005);
            rotationQuaternion.multiplyQuaternions(qY, rotationQuaternion);
            rotationQuaternion.multiplyQuaternions(qX, rotationQuaternion);
            earth.quaternion.copy(rotationQuaternion);
        }

        // ライトのセットアップを関数化
        function setupLights() {
          // 環境ライトを追加
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.2); // 色と強度
          scene.add(ambientLight);
      
          // ディレクショナルライトを追加
          const directionalLight = new THREE.DirectionalLight(0xffffff, 4);
          directionalLight.position.set(5, 3, 5).normalize(); // ライトの位置を設定し、正規化
          scene.add(directionalLight);
        }

        // アニメーション更新を関数化
        function updateAnimation() {
          // 慣性による回転を適用
          applyRotation(velocity.x, velocity.y);
          velocity.x *= friction;
          velocity.y *= friction;
      
          // 慣性が小さくなったら停止
          if (Math.abs(velocity.x) < minVelocityThreshold) velocity.x = 0;
          if (Math.abs(velocity.y) < minVelocityThreshold) velocity.y = 0;
        }        
    </script>  
</body>
</html>
