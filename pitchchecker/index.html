<!-- HTMLドキュメントの開始 -->
<!DOCTYPE html>
<html>
<head>
    <!-- 文字コードの指定 -->
    <meta charset="UTF-8">
    <!-- ウェブページのタイトル -->
    <title>Frequency Spectrum Display</title>
</head>
<body>
    <!-- グラフを描画するためのキャンバス要素 -->
    <canvas id="spectrum" width="400" height="200"></canvas>
    <script>
    // 音のピッチをチェックするクラス
    class PitchChecker {
        constructor() {
            // 今回はコンストラクタにプロパティは不要
        }

        // 周波数をMIDIノート番号に変換するメソッド
        frequencyToNoteNumber(frequency) {
            return 12 * (Math.log(frequency / 440) / Math.log(2)) + 69;
        }

        // MIDIノート番号を音名（A-Gの各音階）に変換するメソッド
        noteNumberToName(noteNumber) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const octave = Math.floor(noteNumber / 12);
            const noteName = noteNames[noteNumber % 12];
            return noteName + octave;
        }

        // 周波数を音名に変換するメソッド
        frequencyToNoteName(frequency) {
            const noteNumber = this.frequencyToNoteNumber(frequency);
            return this.noteNumberToName(Math.round(noteNumber));
        }

        // 音量を計算するメソッド
        calculateVolume(dataArray, bufferLength) {
            let sum = 0;
            let maxIndex = 0;
            for(let i = 0; i < bufferLength; i++) {
                sum += dataArray[i] * dataArray[i];
                if(dataArray[i] > dataArray[maxIndex]) {
                    maxIndex = i;
                }
            }

            const rms = Math.sqrt(sum / bufferLength);
            return { volume: Math.min((rms / 255) * 200, 100), maxIndex: maxIndex };  // 2倍の感度、ただし上限は100
        }
    }

    // 音を視覚化するクラス
    class AudioVisualizer {
        constructor(dataArray, canvas) {
            this.dataArray = dataArray;
            this.canvas = canvas;
            this.context = this.canvas.getContext('2d');
            this.bufferLength = this.dataArray.length;
        }

        // 描画を更新するメソッド
        update() {
            this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
            for(let i = 0; i < this.bufferLength; i++) {
                this.context.fillStyle = `hsl(${i / this.bufferLength * 300}, 100%, 50%)`;
                this.context.fillRect(i * this.canvas.width / this.bufferLength, this.canvas.height, this.canvas.width / this.bufferLength, -(this.dataArray[i] / 255) * this.canvas.height);
            }

            // 描画を継続的に更新するためにrequestAnimationFrameを使う
            requestAnimationFrame(() => this.update());
        }
    }

    // ページが読み込まれたら以下の処理を開始
    window.onload = function() {
        const pitchChecker = new PitchChecker();

        // ユーザーのマイクからの音声データにアクセス
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(stream => {
                const context = new (window.AudioContext || window.webkitAudioContext)();
                const source = context.createMediaStreamSource(stream);
                const analyser = context.createAnalyser();
                analyser.fftSize = 1024;

                source.connect(analyser);

                const spectrumCanvas = document.getElementById('spectrum');
                const bufferLength = analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);

                const visualizer = new AudioVisualizer(dataArray, spectrumCanvas);

                const update = () => {
                    analyser.getByteFrequencyData(dataArray);
                    visualizer.update();
                    requestAnimationFrame(update);
                };

                update();
            })
            .catch(err => {
                // マイクへのアクセスが拒否された場合のエラーメッセージ
                console.error('マイクへのアクセスが許可されていません。ブラウザの設定を確認して、マイクへのアクセスを許可してください。エラー詳細:', err);
            });
    };
    </script>
</body>
</html>
